(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var res = mod._cached ? mod._cached : mod();
    return res;
}

require.paths = [];
require.modules = {};
require.extensions = [".js",".coffee",".ls"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    
    require.define = function (filename, fn) {
        if (require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            return require(file, dirname)
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        var module_ = { exports : {} };
        
        require.modules[filename] = function () {
            require.modules[filename]._cached = module_.exports;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process
            );
            require.modules[filename]._cached = module_.exports;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var queue = [];\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n    \n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n    }\n    \n    return function (fn) {\n        if (canPost) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        }\n        else setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"));

require.define("/moros/test/utils.ls",Function(['require','module','exports','__dirname','__filename','process'],"var __multiply = __curry(function(x, y){ return x * y; });\nDescribe('{} utils', function(){\n  var each, map, ensure, ys, spy, __ref;\n  __ref = require('moros/src/utils'), each = __ref.each, map = __ref.map;\n  ensure = require('noire').ensure;\n  spy = ys = null;\n  beforeEach(function(){\n    spy = sinon.spy();\n    return ys = document.getElementById('xs').childNodes;\n  });\n  Describe('λ each', function(){\n    It('Should curry the arguments.', function(){\n      ensure(each(function(){})).type('function');\n      return ensure(each(function(){}, [1])).equals([1]);\n    });\n    It('Should treat non-sequences as a singleton sequence.', function(){\n      each(spy, 1);\n      return ensure(spy).property('calledOnce').ok();\n    });\n    It('Should apply the iteratee to each item in the sequence.', function(){\n      each(spy, [1, 2, 3]);\n      ensure(spy).property('callCount').same(3);\n      ensure(spy.calledWith([1])).ok;\n      ensure(spy.calledWith([2])).ok;\n      return ensure(spy.calledWith([3])).ok;\n    });\n    return It('Should return the original sequence.', function(){\n      var xs;\n      xs = [1, 2, 3];\n      ensure(each(spy, spy)).same(spy);\n      ensure(each(function(){}, xs)).same(xs);\n      return ensure(each(function(){}, ys)).same(ys);\n    });\n  });\n  return Describe('λ map', function(){\n    It('Should curry the arguments.', function(){\n      ensure(map(function(){})).type('function');\n      return ensure(map(function(x){\n        return x;\n      }, [1])).equals([1]);\n    });\n    It('Should treat non-sequences as a singleton sequence.', function(){\n      return ensure(map(function(x){\n        return x;\n      }, 1)).equals([1]);\n    });\n    return It('Should return an array with each item mapped by the functor.', function(){\n      ensure(map(__multiply(2), [1, 2, 3])).equals([2, 4, 6]);\n      return ensure(map(function(x){\n        return x.nodeName;\n      }, ys)).equals(['#text', 'A', 'IMG', 'IMG', 'DIV', '#text']);\n    });\n  });\n});\nfunction __curry(f, args){\n  return f.length > 1 ? function(){\n    var params = args ? args.concat() : [];\n    return params.push.apply(params, arguments) < f.length && arguments.length ?\n      __curry.call(this, f, params) : f.apply(this, params);\n  } : f;\n}\n//@ sourceURL=/moros/test/utils.ls"));

require.define("/moros/node_modules/moros/src/utils.ls",Function(['require','module','exports','__dirname','__filename','process'],"/** utils.ls --- Shared utilities\n *\n * Version: -:package.version:-\n *\n * Copyright (c) 2012 Quildreen Motta\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation files\n * (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nvar id, k, head, tail, sequenceP, asSequence, toArray, each, map;\nid = function(x){\n  return x;\n};\nk = function(x){\n  return function(){\n    return x;\n  };\n};\nhead = function(xs){\n  return xs[0];\n};\ntail = function(xs){\n  return xs.slice(1);\n};\nsequenceP = function(x){\n  return x && x.length >= 0;\n};\nasSequence = function(x){\n  switch (false) {\n  case !sequenceP(x):\n    return x;\n  default:\n    return [x];\n  }\n};\ntoArray = Function.call.bind([].slice);\neach = __curry(function(f, xs){\n  var i, x, __len;\n  xs = asSequence(xs);\n  for (i = 0, __len = xs.length; i < __len; ++i) {\n    x = xs[i];\n    f(x);\n  }\n  return xs;\n});\nmap = __curry(function(f, xs){\n  var x, __i, __ref, __len, __results = [];\n  for (__i = 0, __len = (__ref = asSequence(xs)).length; __i < __len; ++__i) {\n    x = __ref[__i];\n    __results.push(f(x));\n  }\n  return __results;\n});\nmodule.exports = {\n  asSequence: asSequence,\n  toArray: toArray,\n  head: head,\n  tail: tail,\n  id: id,\n  k: k,\n  each: each,\n  map: map\n};\nfunction __curry(f, args){\n  return f.length > 1 ? function(){\n    var params = args ? args.concat() : [];\n    return params.push.apply(params, arguments) < f.length && arguments.length ?\n      __curry.call(this, f, params) : f.apply(this, params);\n  } : f;\n}\n//@ sourceURL=/moros/node_modules/moros/src/utils.ls"));

require.define("/moros/node_modules/noire/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"./src/index.js\"}\n//@ sourceURL=/moros/node_modules/noire/package.json"));

require.define("/moros/node_modules/noire/src/index.js",Function(['require','module','exports','__dirname','__filename','process'],"require('./matchers')\n\nmodule.exports = require('./core')\n\n//@ sourceURL=/moros/node_modules/noire/src/index.js"));

require.define("/moros/node_modules/noire/src/matchers.js",Function(['require','module','exports','__dirname','__filename','process'],"/// matchers.js --- Common matchers\n//\n// Copyright (c) 2012 Quildreen Motta\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Assertion = require('./core').Assertion\n\nvar array_p   = Array.isArray\nvar keys      = Object.keys\nvar slice     = [].slice.call.bind([].slice)\n\nfunction class_of(subject) {\n  return {}.toString.call(subject).slice(8, -1) }\n\nfunction all(xs, f, idx) {\n  return slice(xs, idx || 0).every(f) }\n\nfunction class_p(cls) {\n  return all(arguments, function(o){ return class_of(o) == cls }, 1)}\n\nfunction type_p(type) {\n  return all(arguments, function(o){ return typeof o == type }, 1) }\n\nfunction arguments_p() {\n  return all(arguments, function(o){ return class_of(o) == 'Arguments' })}\n\nfunction error_p(o) { return o instanceof Error }\n\nfunction re_p(o){ return class_of(o) == 'RegExp' }\n\nfunction string_p(o){ return class_of(o) == 'String' }\n\n\n// Deep strict equality\n//\n// Based on Node.js's assert module's deepEqual\nfunction deep_equal(actual, expected) {\n  return actual === expected\n  ||     eq_date(actual, expected)\n  ||     eq_regexp(actual, expected)\n  ||     eq_abstract(actual, expected)\n  ||     eq_object(actual, expected)\n  ||     false }\n\nfunction eq_date(actual, expected) {\n  return class_p('Date', actual, expected)\n  &&     actual.getTime() === expected.getTime() }\n\nfunction eq_regexp(actual, expected) {\n  return class_p('RegExp', actual, expected)\n  &&     actual.source     === expected.source\n  &&     actual.global     === expected.global\n  &&     actual.multiline  === expected.multiline\n  &&     actual.lastIndex  === expected.lastIndex\n  &&     actual.ignoreCase === expected.ignoreCase }\n\nfunction eq_abstract(actual, expected) {\n  return !type_p('object', actual, expected)\n  &&     actual == expected }\n\nfunction eq_object(actual, expected) {\n  var a, b\n\n  if (actual == null || expected == null)\n    return false\n\n  if (actual.prototype !== expected.prototype)\n    return false\n\n  if (arguments_p(actual)) {\n    if (!arguments_p(expected))  return false\n    return deep_equal(slice(actual), slice(expected)) }\n\n  try {\n    a = keys(actual)\n    b = keys(expected) }\n  catch(e) {\n    return false }\n\n  if (a.length !== b.length)  return false\n\n  a.sort()\n  b.sort()\n  return a.every(function(k, i){ return k == b[i]                             })\n  &&     a.every(function(k, i){ return deep_equal(actual[k], expected[b[i]]) })}\n\n\n\n\n// -- Core matchers --\nAssertion.define('equals'\n, 'equal {:actual}.'\n, function(actual) {\n    this.store('actual', actual)\n    this.satisfy(function(expected) { return deep_equal(actual, expected) })\n})\n\n\nAssertion.define('same'\n, 'be {:actual}.'\n, function(actual) {\n    this.store('actual', actual)\n    this.satisfy(function(expected){ return expected === actual })\n})\n\n\nAssertion.define('exists'\n, 'exist.'\n, function(value) {\n    this.satisfy(function(expected){ return expected !== undefined })\n})\n\n\nAssertion.define('contains'\n, 'contain {:value}.'\n, function(value) {\n    this.store('value', value)\n    this.satisfy(function(expected){ return expected.indexOf(value) !== -1 })\n})\n\n\nAssertion.define('ok'\n, 'be ok.'\n, function() {\n    this.satisfy(function(expected){ return !!expected })\n})\n\n\nAssertion.define('empty'\n, 'be empty.'\n, function() {\n    this.satisfy(function(expected){ return array_p(expected)?  expected.length == 0\n                                     :      /* otherwise */     keys(expected).length == 0 })\n})\n\n\nAssertion.define(['above', '>']\n, 'be above {:value}.'\n, function(value) {\n    this.store('value', value)\n    this.satisfy(function(expected){ return expected > value })\n})\n\n\nAssertion.define(['below', '<']\n, 'be below {:value}.'\n, function(value) {\n    this.store('value', value)\n    this.satisfy(function(expected){ return expected < value })\n})\n\n\nAssertion.define('within'\n, 'be within {:lower} and {:upper}.'\n, function(lower, upper) {\n    this.store('lower', lower)\n    this.store('upper', upper)\n    this.satisfy(function(expected){ return expected >= lower\n                                     &&     expected <= upper })\n})\n\n\nAssertion.define('throws'\n, 'throw {:error}.'\n, function(error) {\n    this.store('error', error_p(error)? error.name : error)\n    if (!error) this.describe('throw anything.', true)\n    this.satisfy(function(expected){ try { expected() }\n                                     catch(e) {\n                                       return !error?           true\n                                       :      string_p(error)?  error == e.name\n                                       :      error_p(error)?   error.name == e.name\n                                       :      re_p(error)?      error.test(e.name)\n                                       :      /* otherwise */   deep_equal(error, e) }})\n})\n\n\nAssertion.define('type'\n, 'have type {:type}, got {:actual-type} instead.'\n, function(type) {\n    this.store('type', type)\n    this.satisfy(function(expected){ var actual = /^[A-Z]/.test(type)?  class_of(expected)\n                                                : /* otherwise */       typeof expected\n                                     this.store('actual-type', actual)\n                                     return type === actual }.bind(this))\n})\n\n\nAssertion.define('matches'\n, 'match the regular expression {:re}.'\n, function(re) {\n    this.store('re', re.toString())\n    this.satisfy(function(expected) { return re.test(expected) })})\n//@ sourceURL=/moros/node_modules/noire/src/matchers.js"));

require.define("/moros/node_modules/noire/src/core.js",Function(['require','module','exports','__dirname','__filename','process'],"/// core.js --- The core of Noire assertions\n//\n// Copyright (c) 2012 Quildreen Motta\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Base = require('boo').Base\nvar array_p = Array.isArray\nvar slice   = [].slice\n\n\nvar Assertion = Base.derive({\n  init:\n  function _init(value) {\n    this._prelude     = 'to'\n    this._message     = ''\n    this._params      = {}\n    this._times       = 100\n\n    return this.expect(value) }\n\n\n, store:\n  function _store(key, value) {\n    this._params[key] = value\n    return this }\n\n\n, expect:\n  function _expect(value) {\n    this._expectation = value\n    this.store('expected', value)\n    return this }\n\n\n, describe:\n  function _describe(message, overwrite) {\n    if (this._message && !overwrite) return this\n\n    this._message = message\n    return this }\n\n\n, message:\n  function _message() {\n    return format( 'Expected {:expected} ' + this._prelude + ' ' + this._message\n                 , this._params )}\n\n\n, define:\n  function _define(name, description, property) {\n    var matcher = function() { this.describe(description)\n                               property.apply(this, arguments)\n                               return this }\n\n    name = array_p(name)?   name\n         : /* otherwise */  [name]\n    name.forEach(function(key){ this[key] = matcher }, this) }\n\n\n, satisfy:\n  function _satisfy(property) {\n    this.store('‹satisfy:property›', property)\n    this.describe('satisfy {:‹satisfy:property›}.')\n\n    if (!this._test(property, this._expectation))\n      throw make_error(this.message())\n\n    return this }\n\n\n, _test:\n  function _test(property) {\n    return property.apply(null, slice.call(arguments, 1)) }\n\n\n, not:\n  function _not() {\n    var test = this._test\n\n    this._prelude += ' not'\n    this._test = function(){ return !test.apply(this, arguments) }\n    return this }\n\n\n, invoke:\n  function _invoke(method) {\n    var args = [].slice.call(arguments, 1)\n    this.store('‹invoke:method›', method)\n    this.store('‹invoke:args›', args)\n    this._prelude = ', when invoking method {:‹invoke:method›} with '\n                  + '{:‹invoke:args›} ' + this._prelude\n    var test = this._test\n    this._test = function(p){ this._expectation = this._expectation[method].apply(this._expectation, args)\n                              this._message += ' Yielded {:‹invoke:result›} instead.'\n                              this.store('‹invoke:result›', this._expectation)\n                              return test.call(this, p, this._expectation) }\n    return this }\n\n\n, property:\n  function _property(name) {\n    this.store('‹property:name›', name)\n    this._prelude += ' yield a value for the property {:‹property:name›} that should'\n    var test = this._test\n    this._test = function(p){ this._expectation = this._expectation[name]\n                              this._message += ' Got {:‹property:actual›} instead.'\n                              this.store('‹property:actual›', this._expectation)\n                              return test.call(this, p, this._expectation) }\n    return this }\n\n\n, all:\n  function _all(generators) {\n    var test   = this._test\n    this._test = random_property_test\n    return this\n\n    function random_property_test(prop, expectation) {\n      var ok    = true\n      var times = 0\n      var args, value\n\n      while (ok && times++ < this._times) {\n        args  = generators.map(function(v){ return v() })\n        value = expectation.apply(null, args)\n        ok    = test(prop, value) }\n\n      this.store('‹all:times›', times)\n      this.store('‹all:args›', args)\n      this.store('‹all:result›', value)\n      this._prelude  = ', given the arguments {:‹all:args›}, '\n                     + this._prelude + ' yield values that should'\n      this._message += '  Failed after {:‹all:times›} test(s) by yielding {:‹all:result›}'\n      return ok }}\n})\n\n\n///// Function starts_with_p\n// Does the `string' start with a given piece of text?\n//\n// starts_with_p :: String, String -> Bool\nfunction starts_with_p(string, what) {\n  return string.slice(0, what.length) == what }\n\n\n///// Function format\n// Evaluates a template, substituting the variables with respect to the\n// environment provided by the given `mappings'.\n//\n// If a mapping is not given, we assume it to be empty, in which case\n// the template variables are simply stripped away.\n//\n// A template variable is a special construct in the form:\n//\n//     :bnf:\n//     <template-variable> ::= \"{:\" <any but \"}\"> \"}\"\n//\n// For example, provide a \"Hello, world!\" template, that adjusts to a\n// given name, one could write:\n//\n//     format(\"Hello, {:subject}!\", { subject: \"world\" })\n//     // => \"Hello, world!\"\n//\n// A template variable can be escaped by placing a backslash between the\n// open-curly braces and the colon, such that the construct would be\n// output verbatim:\n//\n//     // Remember backslashes must be escaped inside Strings.\n//     format(\"Hello, {\\\\:subject}\", { subject: \"world\" })\n//     // => \"Hello, {\\\\:subject}\"\n//\n//\n// format :: String, { String -> String | (String... -> String) } -> String\nfunction format(string, mappings) {\n  mappings = mappings || {}\n  return string.replace(/{(\\\\?:)([^}]+)}/g, resolve_identifier)\n\n  function resolve_identifier(match, mod, key) {\n    return starts_with_p(mod, '\\\\')?  '{:' + key + '}'\n    :      key in mappings?           stringify(mappings[key])\n    :      /* otherwise */            '' }}\n\nfunction stringify(o) {\n  return typeof o == 'function'?    o.name?          '[Function: ' + o.name + ']'\n                                  : /* otherwise */  '`' + o.toString() + '`'\n  :      /* otherwise */          JSON.stringify(o) }\n\nfunction make_error(message) {\n  var e = Error.call(Object.create(Error.prototype), message)\n  e.name = 'AssertionError'\n  return e }\n\n\nfunction ensure(value) {\n  return Assertion.make(value) }\n\n\nmodule.exports = { ensure: ensure\n                 , Assertion: Assertion\n\n                 , internal: { make_error: make_error }\n                 }\n//@ sourceURL=/moros/node_modules/noire/src/core.js"));

require.define("/node_modules/boo/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"./src/boo.js\"}\n//@ sourceURL=/node_modules/boo/package.json"));

require.define("/node_modules/boo/src/boo.js",Function(['require','module','exports','__dirname','__filename','process'],"/// boo.js --- Prototypical utilities\n//\n// Copyright (c) 2011 Quildreen Motta\n//\n// Permission is hereby granted, free of charge, to any person\n// obtaining a copy of this software and associated documentation files\n// (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of the Software,\n// and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/// Module boo\nvoid function(root, exports) {\n  var slice   = [].slice\n    , keys    = Object.keys\n    , inherit = Object.create\n\n\n  \f\n  //// - Interfaces -----------------------------------------------------------\n\n  ///// Interface DataObject\n  // :: { \"to_data\" -> () -> Object }\n\n\n  \f\n  //// - Helpers --------------------------------------------------------------\n\n  ///// Function data_obj_p\n  // :internal:\n  // Checks if the given subject matches the DataObject interface\n  //\n  // data_obj_p :: Any -> Bool\n  function data_obj_p(subject) {\n    return subject != null\n    &&     typeof subject.to_data == 'function' }\n\n\n  ///// Function resolve_mixins\n  // :internal:\n  // Returns the proper mixin for the given object.\n  //\n  // resolve_mixin :: Object -> Object\n  function resolve_mixin(object) {\n    return data_obj_p(object)?  object.to_data()\n    :                           object }\n\n\n  ///// Function fast_extend\n  // :internal:\n  // Extends the target object with the provided mixins, using a\n  // right-most precedence rule — when a there's a property conflict, the\n  // property defined in the last object wins.\n  //\n  // `DataObject's are properly handled by the `resolve_mixin'\n  // function.\n  //\n  // :warning: low-level\n  //    This function is not meant to be called directly from end-user\n  //    code, use the `extend' function instead.\n  //\n  // fast_extend :: Object, [Object | DataObject] -> Object\n  function fast_extend(object, mixins) {\n    var i, j, len, mixin, props, key\n    for (i = 0, len = mixins.length; i < len; ++i) {\n      mixin = resolve_mixin(mixins[i])\n      props = keys(mixin)\n      for (j = props.length; j--;) {\n        key         = props[j]\n        object[key] = mixin[key] }}\n\n    return object }\n\n\n  \f\n  //// - Basic primitives -----------------------------------------------------\n\n  ///// Function extend\n  // Extends the target object with the provided mixins, using a\n  // right-most precedence rule.\n  //\n  // :see-also:\n  //   - `fast_extend' — lower level function.\n  //   - `merge'       — pure version.\n  //\n  // extend :: Object, (Object | DataObject)... -> Object\n  function extend(target) {\n    return fast_extend(target, slice.call(arguments, 1)) }\n\n\n  ///// Function merge\n  // Creates a new object that merges the provided mixins, using a\n  // right-most precedence rule.\n  //\n  // :see-also:\n  //   - `extend' — impure version.\n  //\n  // merge :: (Object | DataObject)... -> Object\n  function merge() {\n    return fast_extend({}, arguments) }\n\n  ///// Function derive\n  // Creates a new object inheriting from the given prototype and extends\n  // the new instance with the provided mixins.\n  //\n  // derive :: Object, (Object | DataObject)... -> Object\n  function derive(proto) {\n    return fast_extend(inherit(proto), slice.call(arguments, 1)) }\n\n\n  \f\n  //// - Root object ----------------------------------------------------------\n\n  ///// Object Base\n  // The root object for basing all the OOP code. Provides the previous\n  // primitive combinators in an easy and OOP-way.\n  var Base = {\n\n    ////// Function make\n    // Constructs new instances of the object the function is being\n    // applied to.\n    //\n    // If the object provides an ``init`` function, that function is\n    // invoked to do initialisation on the new instance.\n    //\n    // make :: Any... -> Object\n    make:\n    function _make() {\n      var result = inherit(this)\n      if (typeof result.init == 'function')\n        result.init.apply(result, arguments)\n\n      return result }\n\n    ////// Function derive\n    // Constructs a new object that inherits from the object this function\n    // is being applied to, and extends it with the provided mixins.\n    //\n    // derive :: (Object | DataObject)... -> Object\n  , derive:\n    function _derive() {\n      return fast_extend(inherit(this), arguments) }}\n\n\n  \f\n  //// - Exports --------------------------------------------------------------\n  exports.extend   = extend\n  exports.merge    = merge\n  exports.derive   = derive\n  exports.Base     = Base\n  exports.internal = { data_obj_p    : data_obj_p\n                     , fast_extend   : fast_extend\n                     , resolve_mixin : resolve_mixin\n                     }\n\n}\n( this\n, typeof exports == 'undefined'? this.boo = this.boo || {}\n  /* otherwise, yay modules! */: exports\n)\n//@ sourceURL=/node_modules/boo/src/boo.js"));

require.define("/moros/test/query.ls",Function(['require','module','exports','__dirname','__filename','process'],"var ensure, selectors, testSet, testSingle;\nensure = require('noire').ensure;\nwindow.require = require;\nselectors = {\n  '#xs *': 5,\n  '#xs a': 2,\n  '#xs a[data-boo]': 0,\n  '#xs img[data-boo=\"1\"]': 1,\n  '#xs img[data-boo=\"2\"]': 0,\n  '#xs div[class~=\"y\"]': 1,\n  '#xs div[class~=\"a\"]': 0,\n  '#xs img[src^=\"bl\"]': 2,\n  '#xs img[src^=\"ah\"]': 0,\n  '#xs img[src$=\"ah\"]': 1,\n  '#xs img[src$=\"bl\"]': 0,\n  '#xs img[src*=\"la\"]': 1,\n  '#xs img[src*=\"gb\"]': 0,\n  '#xs a[lang|=\"en\"]': 1,\n  '#xs > a[lang|=\"pt\"]': 0\n};\ntestSet = __curry(function(ensure, query){\n  var pattern, len, __ref, __results = [];\n  for (pattern in __ref = selectors) {\n    len = __ref[pattern];\n    __results.push(ensure(query(pattern)).property('length').same(len));\n  }\n  return __results;\n});\ntestSingle = __curry(function(ensure, query){\n  var pattern, len, assertion, __ref, __results = [];\n  for (pattern in __ref = selectors) {\n    len = __ref[pattern];\n    assertion = ensure(query(pattern));\n    if (!len) {\n      assertion = assertion.not();\n    }\n    __results.push(assertion.ok());\n  }\n  return __results;\n});\nDescribe('{} query <Native>', function(){\n  var query, queryOne, __ref;\n  __ref = require('moros/src/query')(), query = __ref.query, queryOne = __ref.queryOne;\n  Describe('λ query', function(){\n    It('Should return a set of elements.', function(){\n      ensure(query('a')).type('Array');\n      ensure(query('html')).type('Array');\n      return ensure(query('*')).type('Array');\n    });\n    It('Should select elements using CSS selectors.', function(){\n      return testSet(ensure, query);\n    });\n    return It('Given a context, should return only elements descending from that context.', function(){\n      return ensure(query('div', document.getElementById('xs'))).property('length').same(1);\n    });\n  });\n  return Describe('λ query-one', function(){\n    It('Should return a single element.', function(){\n      ensure(queryOne('a')).type('HTMLAnchorElement');\n      ensure(queryOne('html')).type('HTMLHtmlElement');\n      return ensure(queryOne('*')).type('HTMLHtmlElement');\n    });\n    It('Should select elements using CSS selectors.', function(){\n      return testSingle(ensure, queryOne);\n    });\n    return It('Given a context, should return only elements descending from that context.', function(){\n      return ensure(queryOne('a', document.getElementById('xs')).getAttribute('lang')).same('en-gb');\n    });\n  });\n});\nfunction __curry(f, args){\n  return f.length > 1 ? function(){\n    var params = args ? args.concat() : [];\n    return params.push.apply(params, arguments) < f.length && arguments.length ?\n      __curry.call(this, f, params) : f.apply(this, params);\n  } : f;\n}\n//@ sourceURL=/moros/test/query.ls"));

require.define("/moros/node_modules/moros/src/query.ls",Function(['require','module','exports','__dirname','__filename','process'],"/** query.ls --- Selects a set of nodes using CSS selectors\n *\n * Version: -:package.version:-\n *\n * Copyright (c) 2012 Quildreen Motta\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation files\n * (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nmodule.exports = function(engine){\n  var head, toArray, query, queryOne;\n  head = require('./utils').head;\n  toArray = Function.call.bind([].slice);\n  query = function(selector, context){\n    context == null && (context = document);\n    return toArray(context.querySelectorAll(selector));\n  };\n  queryOne = function(selector, context){\n    context == null && (context = document);\n    return context.querySelector(selector);\n  };\n  if (engine) {\n    return {\n      query: engine,\n      queryOne: function(selector, context){\n        return head(engine(selector, context));\n      }\n    };\n  } else {\n    return {\n      query: query,\n      queryOne: queryOne\n    };\n  }\n};\n//@ sourceURL=/moros/node_modules/moros/src/query.ls"));

require.define("/moros/test/browser/suite.ls",Function(['require','module','exports','__dirname','__filename','process'],"var __ref;\n__ref = typeof global != 'undefined' && global !== null ? global : window;\n__ref.Describe = describe;\n__ref.It = it;\nrequire('../utils');\nrequire('../query');\n//@ sourceURL=/moros/test/browser/suite.ls"));
require("/moros/test/browser/suite.ls");
})();
